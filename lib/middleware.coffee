
coffeeScript = require 'coffee-script'
fs = require 'fs'
path = require 'path'
url = require 'url'
mkdirp = require 'mkdirp'
debug = require('debug')('connect-coffee-script');

###
Return Connect middleware with the given `options`.

Options:

     `force`         Always re-compile
     `src`             Source directory used to find .styl files
     `dest`            Destination directory used to output .css files
                             when undefined defaults to `src`.
     `compile`     Custom compile function, accepting the arguments
                             `(str, options)`.

     `bare`            Compile without a top-level function wrapper

Examples:

Here we set up the custom compile function so that we may
set the `compress` option, or define additional functions.

By default the compile function simply sets the `filename`
and renders the CSS.

         function compile(str, options) {
             options.bare = true;
             return coffeeScript.compile(str, options);
         }

Pass the middleware to Connect, grabbing .coffee files from this directory
and saving .js files to _./public_. Also supplying our custom `compile` function.

Following that we have a `static()` layer setup to serve the .css
files generated by Stylus.

         var coffeeScript = require('coffee-script');
         var connectCoffeescript = require('connect-coffee-script');
         var connect = require('connect');

         var app = connect();

         app.use(connectCoffeescript({
                 src: __dirname
             , dest: __dirname + '/public'
             , compile: compile
         }));

         app.use(connect.static(__dirname + '/public'));

@param {Object} options
@return {Function}
@api public
###

module.exports = (options = {}) ->

    # Accept src/dest dir
    if typeof options is 'string'
        options = src: options

    # Source dir required
    src = options.src
    throw new Error 'Coffeescript middleware requires "src" directory' unless src

    # Default dest dir to source
    dest = if options.dest then options.dest else src

    # Default compile callback
    options.compile ?= (str, options) ->
        coffeeScript.compile str, options

    # Middleware
    (req, res, next) ->
        return next() if 'GET' isnt req.method and 'HEAD' isnt req.method
        pathname = url.parse(req.url).pathname
        if /\.js$/.test pathname
            jsPath = path.join dest, pathname
            coffeePath = path.join src, pathname.replace '.js', '.coffee'

            # Ignore ENOENT to fall through as 404
            error = (err) ->
                arg = if 'ENOENT' is err.code then null else err
                next arg

            # Compile to jsPath
            compile = ->
                debug 'read %s', jsPath
                fs.readFile coffeePath, 'utf8', (err, str) ->
                    return error err if err
                    try
                        js = options.compile str, options
                    catch err
                        return next err
                    debug('render %s', coffeePath);
                    mkdirp path.dirname(jsPath), 0o0700, (err) ->
                        return error err if err
                        fs.writeFile jsPath, js, 'utf8', next

            # Force compilation
            return compile() if options.force

            # Compare mtimes
            fs.stat coffeePath, (err, coffeeStats) ->
                return error err if err
                fs.stat jsPath, (err, jsStats) ->
                    # JS has not been compiled, compile it!
                    if err
                        if 'ENOENT' is err.code
                            debug 'not found %s', jsPath
                            compile()
                        else
                            next err
                    else
                        # Source has changed, compile it
                        if coffeeStats.mtime > jsStats.mtime
                            debug('modified %s', jsPath)
                            compile()
                        else
                            next()
        else
            next()
